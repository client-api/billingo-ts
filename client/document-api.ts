/* tslint:disable */
/* eslint-disable */
/**
 * Billingo API v3
 * This is a Billingo API v3 documentation. Our API based on REST software architectural style. API has resource-oriented URLs, accepts JSON-encoded request bodies and returns JSON-encoded responses. To use this API you have to generate a new API key on our [site](https://app.billingo.hu/api-key). After that, you can test your API key on this page.
 *
 * The version of the OpenAPI document: 3.0.14
 * Contact: hello@billingo.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ClientError } from '../models';
// @ts-ignore
import { ClientErrorResponse } from '../models';
// @ts-ignore
import { Document } from '../models';
// @ts-ignore
import { DocumentCancellation } from '../models';
// @ts-ignore
import { DocumentInsert } from '../models';
// @ts-ignore
import { DocumentList } from '../models';
// @ts-ignore
import { DocumentPublicUrl } from '../models';
// @ts-ignore
import { DocumentType } from '../models';
// @ts-ignore
import { InvoiceSettings } from '../models';
// @ts-ignore
import { ModificationDocumentInsert } from '../models';
// @ts-ignore
import { OnlineSzamlaStatus } from '../models';
// @ts-ignore
import { PaymentHistory } from '../models';
// @ts-ignore
import { PaymentMethod } from '../models';
// @ts-ignore
import { PaymentStatus } from '../models';
// @ts-ignore
import { ReceiptInsert } from '../models';
// @ts-ignore
import { SendDocument } from '../models';
// @ts-ignore
import { ServerErrorResponse } from '../models';
// @ts-ignore
import { SubscriptionErrorResponse } from '../models';
// @ts-ignore
import { TooManyRequestsResponse } from '../models';
// @ts-ignore
import { ValidationErrorResponse } from '../models';
/**
 * DocumentApi - axios parameter creator
 * @export
 */
export const DocumentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive an existing proforma document.
         * @summary Archive a proforma document.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDocument: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('archiveDocument', 'id', id)
            const localVarPath = `/documents/{id}/archive`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel a document. Returns a cancellation document object if the cancellation is succeded.
         * @summary Cancel a document
         * @param {number} id 
         * @param {DocumentCancellation} [documentCancellation] Comment and notifiable email addresses - comma separated for multiple email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDocument: async (id: number, documentCancellation?: DocumentCancellation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancelDocument', 'id', id)
            const localVarPath = `/documents/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentCancellation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document. Returns a document object if the create is succeded.
         * @summary Create a document
         * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument: async (documentInsert: DocumentInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentInsert' is not null or undefined
            assertParamExists('createDocument', 'documentInsert', documentInsert)
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts a draft to an invoice. Returns the invoice object if the convert is succeded.
         * @summary Converts a draft to an invoice.
         * @param {number} id 
         * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromDraft: async (id: number, documentInsert: DocumentInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createDocumentFromDraft', 'id', id)
            // verify required parameter 'documentInsert' is not null or undefined
            assertParamExists('createDocumentFromDraft', 'documentInsert', documentInsert)
            const localVarPath = `/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new document from proforma. Returns a document object if the create is succeded.
         * @summary Create a document from proforma.
         * @param {number} id 
         * @param {InvoiceSettings} [invoiceSettings] InvoiceSettings object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromProforma: async (id: number, invoiceSettings?: InvoiceSettings, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createDocumentFromProforma', 'id', id)
            const localVarPath = `/documents/{id}/create-from-proforma`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(invoiceSettings, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a modification document for the given document. Returns a new document object if the create is successful.
         * @summary Create a modification document.
         * @param {number} id 
         * @param {ModificationDocumentInsert} modificationDocumentInsert ModificationDocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModificationDocument: async (id: number, modificationDocumentInsert: ModificationDocumentInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createModificationDocument', 'id', id)
            // verify required parameter 'modificationDocumentInsert' is not null or undefined
            assertParamExists('createModificationDocument', 'modificationDocumentInsert', modificationDocumentInsert)
            const localVarPath = `/documents/{id}/create-modification-document`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modificationDocumentInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new receipt. Returns a document object if the create is succeded.
         * @summary Create a receipt
         * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceipt: async (receiptInsert: ReceiptInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'receiptInsert' is not null or undefined
            assertParamExists('createReceipt', 'receiptInsert', receiptInsert)
            const localVarPath = `/documents/receipt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(receiptInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Converts a draft to a receipt. Returns the receipt object if the convert is succeded.
         * @summary Converts a draft to a receipt.
         * @param {number} id 
         * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceiptFromDraft: async (id: number, receiptInsert: ReceiptInsert, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createReceiptFromDraft', 'id', id)
            // verify required parameter 'receiptInsert' is not null or undefined
            assertParamExists('createReceiptFromDraft', 'receiptInsert', receiptInsert)
            const localVarPath = `/documents/receipt/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(receiptInsert, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an existing draft.
         * @summary Delete a draft.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDocument', 'id', id)
            const localVarPath = `/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all exist payment history on document.
         * @summary Delete all payment history on document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayment: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePayment', 'id', id)
            const localVarPath = `/documents/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Copy a document. Returns the new document if the copy was succeded.
         * @summary Copy a document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentCopy: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('documentCopy', 'id', id)
            const localVarPath = `/documents/{id}/copy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download a document. Returns a document in PDF format.
         * @summary Download a document in PDF format.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadDocument', 'id', id)
            const localVarPath = `/documents/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing document.
         * @summary Retrieve a document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDocument', 'id', id)
            const localVarPath = `/documents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing document by vendor id.
         * @summary Retrieve a document by vendor id
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentByVendorId: async (vendorId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'vendorId' is not null or undefined
            assertParamExists('getDocumentByVendorId', 'vendorId', vendorId)
            const localVarPath = `/documents/vendor/{vendor_id}`
                .replace(`{${"vendor_id"}}`, encodeURIComponent(String(vendorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of an existing document status.
         * @summary Retrieve a document Online Sz√°mla status
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnlineSzamlaStatus: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOnlineSzamlaStatus', 'id', id)
            const localVarPath = `/documents/{id}/online-szamla`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the details of payment history an existing document.
         * @summary Retrieve a payment histroy
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPayment', 'id', id)
            const localVarPath = `/documents/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves public url to download an existing document.
         * @summary Retrieve a document download public url.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUrl: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublicUrl', 'id', id)
            const localVarPath = `/documents/{id}/public-url`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of your documents. The documents are returned sorted by creation date, with the most recent documents appearing first.
         * @summary List all documents
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [blockId] Filter documents by the identifier of your DocumentBlock.
         * @param {number} [partnerId] Filter documents by the identifier of your Partner.
         * @param {PaymentMethod} [paymentMethod] Filter documents by PaymentMethod value.
         * @param {PaymentStatus} [paymentStatus] Filter documents by PaymentStatus value.
         * @param {string} [startDate] Filter documents by their invoice date.
         * @param {string} [endDate] Filter documents by their invoice date.
         * @param {number} [startNumber] Starting number of the document, should not contain year or any other formatting. Required if &#x60;start_year&#x60; given
         * @param {number} [endNumber] Ending number of the document, should not contain year or any other formatting. Required if &#x60;end_year&#x60; given
         * @param {number} [startYear] Year for &#x60;start_number&#x60; parameter. Required if &#x60;start_number&#x60; given.
         * @param {number} [endYear] Year for &#x60;end_number&#x60; parameter. Required if &#x60;end_number&#x60; given.
         * @param {DocumentType} [type] Filter documents by type
         * @param {string} [query] Filter documents by the given text
         * @param {string} [paidStartDate] Filter documents by their payment date.
         * @param {string} [paidEndDate] Filter documents by their payment date.
         * @param {string} [fulfillmentStartDate] Filter documents by their fulfillment date.
         * @param {string} [fulfillmentEndDate] Filter documents by their fulfillment date.
         * @param {string} [lastModifiedDate] Filter documents by their last modified date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocument: async (page?: number, perPage?: number, blockId?: number, partnerId?: number, paymentMethod?: PaymentMethod, paymentStatus?: PaymentStatus, startDate?: string, endDate?: string, startNumber?: number, endNumber?: number, startYear?: number, endYear?: number, type?: DocumentType, query?: string, paidStartDate?: string, paidEndDate?: string, fulfillmentStartDate?: string, fulfillmentEndDate?: string, lastModifiedDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }

            if (blockId !== undefined) {
                localVarQueryParameter['block_id'] = blockId;
            }

            if (partnerId !== undefined) {
                localVarQueryParameter['partner_id'] = partnerId;
            }

            if (paymentMethod !== undefined) {
                localVarQueryParameter['payment_method'] = paymentMethod;
            }

            if (paymentStatus !== undefined) {
                localVarQueryParameter['payment_status'] = paymentStatus;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (startNumber !== undefined) {
                localVarQueryParameter['start_number'] = startNumber;
            }

            if (endNumber !== undefined) {
                localVarQueryParameter['end_number'] = endNumber;
            }

            if (startYear !== undefined) {
                localVarQueryParameter['start_year'] = startYear;
            }

            if (endYear !== undefined) {
                localVarQueryParameter['end_year'] = endYear;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (paidStartDate !== undefined) {
                localVarQueryParameter['paid_start_date'] = (paidStartDate as any instanceof Date) ?
                    (paidStartDate as any).toISOString().substring(0,10) :
                    paidStartDate;
            }

            if (paidEndDate !== undefined) {
                localVarQueryParameter['paid_end_date'] = (paidEndDate as any instanceof Date) ?
                    (paidEndDate as any).toISOString().substring(0,10) :
                    paidEndDate;
            }

            if (fulfillmentStartDate !== undefined) {
                localVarQueryParameter['fulfillment_start_date'] = (fulfillmentStartDate as any instanceof Date) ?
                    (fulfillmentStartDate as any).toISOString().substring(0,10) :
                    fulfillmentStartDate;
            }

            if (fulfillmentEndDate !== undefined) {
                localVarQueryParameter['fulfillment_end_date'] = (fulfillmentEndDate as any instanceof Date) ?
                    (fulfillmentEndDate as any).toISOString().substring(0,10) :
                    fulfillmentEndDate;
            }

            if (lastModifiedDate !== undefined) {
                localVarQueryParameter['last_modified_date'] = lastModifiedDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a printable POS PDF file of a particular document.
         * @summary Returns a printable POS PDF
         * @param {number} id 
         * @param {PosPrintSizeEnum} size In which size the POS PDF should be rendered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posPrint: async (id: number, size: PosPrintSizeEnum, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('posPrint', 'id', id)
            // verify required parameter 'size' is not null or undefined
            assertParamExists('posPrint', 'size', size)
            const localVarPath = `/documents/{id}/print/pos`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of emails, where the invoice is sent.
         * @summary Send invoice to given email adresses.
         * @param {number} id 
         * @param {SendDocument} [sendDocument] List of email-s where you want to send the invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDocument: async (id: number, sendDocument?: SendDocument, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('sendDocument', 'id', id)
            const localVarPath = `/documents/{id}/send`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendDocument, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update payment history an existing document. Returns a payment history object if the update is succeded.
         * @summary Update payment history
         * @param {number} id 
         * @param {Array<PaymentHistory>} paymentHistory Payment history object that you would like to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment: async (id: number, paymentHistory: Array<PaymentHistory>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePayment', 'id', id)
            // verify required parameter 'paymentHistory' is not null or undefined
            assertParamExists('updatePayment', 'paymentHistory', paymentHistory)
            const localVarPath = `/documents/{id}/payments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "X-API-KEY", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(paymentHistory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentApiAxiosParamCreator(configuration)
    return {
        /**
         * Archive an existing proforma document.
         * @summary Archive a proforma document.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveDocument(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.archiveDocument(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancel a document. Returns a cancellation document object if the cancellation is succeded.
         * @summary Cancel a document
         * @param {number} id 
         * @param {DocumentCancellation} [documentCancellation] Comment and notifiable email addresses - comma separated for multiple email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelDocument(id: number, documentCancellation?: DocumentCancellation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelDocument(id, documentCancellation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new document. Returns a document object if the create is succeded.
         * @summary Create a document
         * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocument(documentInsert: DocumentInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocument(documentInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Converts a draft to an invoice. Returns the invoice object if the convert is succeded.
         * @summary Converts a draft to an invoice.
         * @param {number} id 
         * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentFromDraft(id: number, documentInsert: DocumentInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentFromDraft(id, documentInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new document from proforma. Returns a document object if the create is succeded.
         * @summary Create a document from proforma.
         * @param {number} id 
         * @param {InvoiceSettings} [invoiceSettings] InvoiceSettings object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDocumentFromProforma(id: number, invoiceSettings?: InvoiceSettings, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDocumentFromProforma(id, invoiceSettings, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a modification document for the given document. Returns a new document object if the create is successful.
         * @summary Create a modification document.
         * @param {number} id 
         * @param {ModificationDocumentInsert} modificationDocumentInsert ModificationDocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModificationDocument(id: number, modificationDocumentInsert: ModificationDocumentInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModificationDocument(id, modificationDocumentInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new receipt. Returns a document object if the create is succeded.
         * @summary Create a receipt
         * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReceipt(receiptInsert: ReceiptInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReceipt(receiptInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Converts a draft to a receipt. Returns the receipt object if the convert is succeded.
         * @summary Converts a draft to a receipt.
         * @param {number} id 
         * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReceiptFromDraft(id: number, receiptInsert: ReceiptInsert, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReceiptFromDraft(id, receiptInsert, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an existing draft.
         * @summary Delete a draft.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocument(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocument(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete all exist payment history on document.
         * @summary Delete all payment history on document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePayment(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePayment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Copy a document. Returns the new document if the copy was succeded.
         * @summary Copy a document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async documentCopy(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.documentCopy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Download a document. Returns a document in PDF format.
         * @summary Download a document in PDF format.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocument(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocument(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing document.
         * @summary Retrieve a document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocument(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocument(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing document by vendor id.
         * @summary Retrieve a document by vendor id
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentByVendorId(vendorId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Document>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentByVendorId(vendorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of an existing document status.
         * @summary Retrieve a document Online Sz√°mla status
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOnlineSzamlaStatus(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OnlineSzamlaStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOnlineSzamlaStatus(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves the details of payment history an existing document.
         * @summary Retrieve a payment histroy
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayment(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayment(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieves public url to download an existing document.
         * @summary Retrieve a document download public url.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUrl(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentPublicUrl>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicUrl(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of your documents. The documents are returned sorted by creation date, with the most recent documents appearing first.
         * @summary List all documents
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [blockId] Filter documents by the identifier of your DocumentBlock.
         * @param {number} [partnerId] Filter documents by the identifier of your Partner.
         * @param {PaymentMethod} [paymentMethod] Filter documents by PaymentMethod value.
         * @param {PaymentStatus} [paymentStatus] Filter documents by PaymentStatus value.
         * @param {string} [startDate] Filter documents by their invoice date.
         * @param {string} [endDate] Filter documents by their invoice date.
         * @param {number} [startNumber] Starting number of the document, should not contain year or any other formatting. Required if &#x60;start_year&#x60; given
         * @param {number} [endNumber] Ending number of the document, should not contain year or any other formatting. Required if &#x60;end_year&#x60; given
         * @param {number} [startYear] Year for &#x60;start_number&#x60; parameter. Required if &#x60;start_number&#x60; given.
         * @param {number} [endYear] Year for &#x60;end_number&#x60; parameter. Required if &#x60;end_number&#x60; given.
         * @param {DocumentType} [type] Filter documents by type
         * @param {string} [query] Filter documents by the given text
         * @param {string} [paidStartDate] Filter documents by their payment date.
         * @param {string} [paidEndDate] Filter documents by their payment date.
         * @param {string} [fulfillmentStartDate] Filter documents by their fulfillment date.
         * @param {string} [fulfillmentEndDate] Filter documents by their fulfillment date.
         * @param {string} [lastModifiedDate] Filter documents by their last modified date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocument(page?: number, perPage?: number, blockId?: number, partnerId?: number, paymentMethod?: PaymentMethod, paymentStatus?: PaymentStatus, startDate?: string, endDate?: string, startNumber?: number, endNumber?: number, startYear?: number, endYear?: number, type?: DocumentType, query?: string, paidStartDate?: string, paidEndDate?: string, fulfillmentStartDate?: string, fulfillmentEndDate?: string, lastModifiedDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocument(page, perPage, blockId, partnerId, paymentMethod, paymentStatus, startDate, endDate, startNumber, endNumber, startYear, endYear, type, query, paidStartDate, paidEndDate, fulfillmentStartDate, fulfillmentEndDate, lastModifiedDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a printable POS PDF file of a particular document.
         * @summary Returns a printable POS PDF
         * @param {number} id 
         * @param {PosPrintSizeEnum} size In which size the POS PDF should be rendered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async posPrint(id: number, size: PosPrintSizeEnum, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.posPrint(id, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of emails, where the invoice is sent.
         * @summary Send invoice to given email adresses.
         * @param {number} id 
         * @param {SendDocument} [sendDocument] List of email-s where you want to send the invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendDocument(id: number, sendDocument?: SendDocument, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendDocument>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendDocument(id, sendDocument, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update payment history an existing document. Returns a payment history object if the update is succeded.
         * @summary Update payment history
         * @param {number} id 
         * @param {Array<PaymentHistory>} paymentHistory Payment history object that you would like to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePayment(id: number, paymentHistory: Array<PaymentHistory>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PaymentHistory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePayment(id, paymentHistory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentApiFp(configuration)
    return {
        /**
         * Archive an existing proforma document.
         * @summary Archive a proforma document.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDocument(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.archiveDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel a document. Returns a cancellation document object if the cancellation is succeded.
         * @summary Cancel a document
         * @param {number} id 
         * @param {DocumentCancellation} [documentCancellation] Comment and notifiable email addresses - comma separated for multiple email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelDocument(id: number, documentCancellation?: DocumentCancellation, options?: any): AxiosPromise<Document> {
            return localVarFp.cancelDocument(id, documentCancellation, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document. Returns a document object if the create is succeded.
         * @summary Create a document
         * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocument(documentInsert: DocumentInsert, options?: any): AxiosPromise<Document> {
            return localVarFp.createDocument(documentInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * Converts a draft to an invoice. Returns the invoice object if the convert is succeded.
         * @summary Converts a draft to an invoice.
         * @param {number} id 
         * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromDraft(id: number, documentInsert: DocumentInsert, options?: any): AxiosPromise<Document> {
            return localVarFp.createDocumentFromDraft(id, documentInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new document from proforma. Returns a document object if the create is succeded.
         * @summary Create a document from proforma.
         * @param {number} id 
         * @param {InvoiceSettings} [invoiceSettings] InvoiceSettings object.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDocumentFromProforma(id: number, invoiceSettings?: InvoiceSettings, options?: any): AxiosPromise<Document> {
            return localVarFp.createDocumentFromProforma(id, invoiceSettings, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a modification document for the given document. Returns a new document object if the create is successful.
         * @summary Create a modification document.
         * @param {number} id 
         * @param {ModificationDocumentInsert} modificationDocumentInsert ModificationDocumentInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModificationDocument(id: number, modificationDocumentInsert: ModificationDocumentInsert, options?: any): AxiosPromise<Document> {
            return localVarFp.createModificationDocument(id, modificationDocumentInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new receipt. Returns a document object if the create is succeded.
         * @summary Create a receipt
         * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceipt(receiptInsert: ReceiptInsert, options?: any): AxiosPromise<Document> {
            return localVarFp.createReceipt(receiptInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * Converts a draft to a receipt. Returns the receipt object if the convert is succeded.
         * @summary Converts a draft to a receipt.
         * @param {number} id 
         * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReceiptFromDraft(id: number, receiptInsert: ReceiptInsert, options?: any): AxiosPromise<Document> {
            return localVarFp.createReceiptFromDraft(id, receiptInsert, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an existing draft.
         * @summary Delete a draft.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all exist payment history on document.
         * @summary Delete all payment history on document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePayment(id: number, options?: any): AxiosPromise<Array<PaymentHistory>> {
            return localVarFp.deletePayment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Copy a document. Returns the new document if the copy was succeded.
         * @summary Copy a document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        documentCopy(id: number, options?: any): AxiosPromise<Document> {
            return localVarFp.documentCopy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Download a document. Returns a document in PDF format.
         * @summary Download a document in PDF format.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(id: number, options?: any): AxiosPromise<File> {
            return localVarFp.downloadDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing document.
         * @summary Retrieve a document
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocument(id: number, options?: any): AxiosPromise<Document> {
            return localVarFp.getDocument(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing document by vendor id.
         * @summary Retrieve a document by vendor id
         * @param {string} vendorId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentByVendorId(vendorId: string, options?: any): AxiosPromise<Document> {
            return localVarFp.getDocumentByVendorId(vendorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of an existing document status.
         * @summary Retrieve a document Online Sz√°mla status
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOnlineSzamlaStatus(id: number, options?: any): AxiosPromise<OnlineSzamlaStatus> {
            return localVarFp.getOnlineSzamlaStatus(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the details of payment history an existing document.
         * @summary Retrieve a payment histroy
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(id: number, options?: any): AxiosPromise<Array<PaymentHistory>> {
            return localVarFp.getPayment(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves public url to download an existing document.
         * @summary Retrieve a document download public url.
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUrl(id: number, options?: any): AxiosPromise<DocumentPublicUrl> {
            return localVarFp.getPublicUrl(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of your documents. The documents are returned sorted by creation date, with the most recent documents appearing first.
         * @summary List all documents
         * @param {number} [page] 
         * @param {number} [perPage] 
         * @param {number} [blockId] Filter documents by the identifier of your DocumentBlock.
         * @param {number} [partnerId] Filter documents by the identifier of your Partner.
         * @param {PaymentMethod} [paymentMethod] Filter documents by PaymentMethod value.
         * @param {PaymentStatus} [paymentStatus] Filter documents by PaymentStatus value.
         * @param {string} [startDate] Filter documents by their invoice date.
         * @param {string} [endDate] Filter documents by their invoice date.
         * @param {number} [startNumber] Starting number of the document, should not contain year or any other formatting. Required if &#x60;start_year&#x60; given
         * @param {number} [endNumber] Ending number of the document, should not contain year or any other formatting. Required if &#x60;end_year&#x60; given
         * @param {number} [startYear] Year for &#x60;start_number&#x60; parameter. Required if &#x60;start_number&#x60; given.
         * @param {number} [endYear] Year for &#x60;end_number&#x60; parameter. Required if &#x60;end_number&#x60; given.
         * @param {DocumentType} [type] Filter documents by type
         * @param {string} [query] Filter documents by the given text
         * @param {string} [paidStartDate] Filter documents by their payment date.
         * @param {string} [paidEndDate] Filter documents by their payment date.
         * @param {string} [fulfillmentStartDate] Filter documents by their fulfillment date.
         * @param {string} [fulfillmentEndDate] Filter documents by their fulfillment date.
         * @param {string} [lastModifiedDate] Filter documents by their last modified date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocument(page?: number, perPage?: number, blockId?: number, partnerId?: number, paymentMethod?: PaymentMethod, paymentStatus?: PaymentStatus, startDate?: string, endDate?: string, startNumber?: number, endNumber?: number, startYear?: number, endYear?: number, type?: DocumentType, query?: string, paidStartDate?: string, paidEndDate?: string, fulfillmentStartDate?: string, fulfillmentEndDate?: string, lastModifiedDate?: string, options?: any): AxiosPromise<DocumentList> {
            return localVarFp.listDocument(page, perPage, blockId, partnerId, paymentMethod, paymentStatus, startDate, endDate, startNumber, endNumber, startYear, endYear, type, query, paidStartDate, paidEndDate, fulfillmentStartDate, fulfillmentEndDate, lastModifiedDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a printable POS PDF file of a particular document.
         * @summary Returns a printable POS PDF
         * @param {number} id 
         * @param {PosPrintSizeEnum} size In which size the POS PDF should be rendered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        posPrint(id: number, size: PosPrintSizeEnum, options?: any): AxiosPromise<File> {
            return localVarFp.posPrint(id, size, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of emails, where the invoice is sent.
         * @summary Send invoice to given email adresses.
         * @param {number} id 
         * @param {SendDocument} [sendDocument] List of email-s where you want to send the invoice.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendDocument(id: number, sendDocument?: SendDocument, options?: any): AxiosPromise<SendDocument> {
            return localVarFp.sendDocument(id, sendDocument, options).then((request) => request(axios, basePath));
        },
        /**
         * Update payment history an existing document. Returns a payment history object if the update is succeded.
         * @summary Update payment history
         * @param {number} id 
         * @param {Array<PaymentHistory>} paymentHistory Payment history object that you would like to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePayment(id: number, paymentHistory: Array<PaymentHistory>, options?: any): AxiosPromise<Array<PaymentHistory>> {
            return localVarFp.updatePayment(id, paymentHistory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentApi - interface
 * @export
 * @interface DocumentApi
 */
export interface DocumentApiInterface {
    /**
     * Archive an existing proforma document.
     * @summary Archive a proforma document.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    archiveDocument(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Cancel a document. Returns a cancellation document object if the cancellation is succeded.
     * @summary Cancel a document
     * @param {number} id 
     * @param {DocumentCancellation} [documentCancellation] Comment and notifiable email addresses - comma separated for multiple email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    cancelDocument(id: number, documentCancellation?: DocumentCancellation, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Create a new document. Returns a document object if the create is succeded.
     * @summary Create a document
     * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    createDocument(documentInsert: DocumentInsert, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Converts a draft to an invoice. Returns the invoice object if the convert is succeded.
     * @summary Converts a draft to an invoice.
     * @param {number} id 
     * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    createDocumentFromDraft(id: number, documentInsert: DocumentInsert, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Create a new document from proforma. Returns a document object if the create is succeded.
     * @summary Create a document from proforma.
     * @param {number} id 
     * @param {InvoiceSettings} [invoiceSettings] InvoiceSettings object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    createDocumentFromProforma(id: number, invoiceSettings?: InvoiceSettings, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Create a modification document for the given document. Returns a new document object if the create is successful.
     * @summary Create a modification document.
     * @param {number} id 
     * @param {ModificationDocumentInsert} modificationDocumentInsert ModificationDocumentInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    createModificationDocument(id: number, modificationDocumentInsert: ModificationDocumentInsert, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Create a new receipt. Returns a document object if the create is succeded.
     * @summary Create a receipt
     * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    createReceipt(receiptInsert: ReceiptInsert, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Converts a draft to a receipt. Returns the receipt object if the convert is succeded.
     * @summary Converts a draft to a receipt.
     * @param {number} id 
     * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    createReceiptFromDraft(id: number, receiptInsert: ReceiptInsert, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Delete an existing draft.
     * @summary Delete a draft.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    deleteDocument(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * Delete all exist payment history on document.
     * @summary Delete all payment history on document
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    deletePayment(id: number, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentHistory>>;

    /**
     * Copy a document. Returns the new document if the copy was succeded.
     * @summary Copy a document
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    documentCopy(id: number, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Download a document. Returns a document in PDF format.
     * @summary Download a document in PDF format.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    downloadDocument(id: number, options?: AxiosRequestConfig): AxiosPromise<File>;

    /**
     * Retrieves the details of an existing document.
     * @summary Retrieve a document
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    getDocument(id: number, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Retrieves the details of an existing document by vendor id.
     * @summary Retrieve a document by vendor id
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    getDocumentByVendorId(vendorId: string, options?: AxiosRequestConfig): AxiosPromise<Document>;

    /**
     * Retrieves the details of an existing document status.
     * @summary Retrieve a document Online Sz√°mla status
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    getOnlineSzamlaStatus(id: number, options?: AxiosRequestConfig): AxiosPromise<OnlineSzamlaStatus>;

    /**
     * Retrieves the details of payment history an existing document.
     * @summary Retrieve a payment histroy
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    getPayment(id: number, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentHistory>>;

    /**
     * Retrieves public url to download an existing document.
     * @summary Retrieve a document download public url.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    getPublicUrl(id: number, options?: AxiosRequestConfig): AxiosPromise<DocumentPublicUrl>;

    /**
     * Returns a list of your documents. The documents are returned sorted by creation date, with the most recent documents appearing first.
     * @summary List all documents
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [blockId] Filter documents by the identifier of your DocumentBlock.
     * @param {number} [partnerId] Filter documents by the identifier of your Partner.
     * @param {PaymentMethod} [paymentMethod] Filter documents by PaymentMethod value.
     * @param {PaymentStatus} [paymentStatus] Filter documents by PaymentStatus value.
     * @param {string} [startDate] Filter documents by their invoice date.
     * @param {string} [endDate] Filter documents by their invoice date.
     * @param {number} [startNumber] Starting number of the document, should not contain year or any other formatting. Required if &#x60;start_year&#x60; given
     * @param {number} [endNumber] Ending number of the document, should not contain year or any other formatting. Required if &#x60;end_year&#x60; given
     * @param {number} [startYear] Year for &#x60;start_number&#x60; parameter. Required if &#x60;start_number&#x60; given.
     * @param {number} [endYear] Year for &#x60;end_number&#x60; parameter. Required if &#x60;end_number&#x60; given.
     * @param {DocumentType} [type] Filter documents by type
     * @param {string} [query] Filter documents by the given text
     * @param {string} [paidStartDate] Filter documents by their payment date.
     * @param {string} [paidEndDate] Filter documents by their payment date.
     * @param {string} [fulfillmentStartDate] Filter documents by their fulfillment date.
     * @param {string} [fulfillmentEndDate] Filter documents by their fulfillment date.
     * @param {string} [lastModifiedDate] Filter documents by their last modified date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    listDocument(page?: number, perPage?: number, blockId?: number, partnerId?: number, paymentMethod?: PaymentMethod, paymentStatus?: PaymentStatus, startDate?: string, endDate?: string, startNumber?: number, endNumber?: number, startYear?: number, endYear?: number, type?: DocumentType, query?: string, paidStartDate?: string, paidEndDate?: string, fulfillmentStartDate?: string, fulfillmentEndDate?: string, lastModifiedDate?: string, options?: AxiosRequestConfig): AxiosPromise<DocumentList>;

    /**
     * Returns a printable POS PDF file of a particular document.
     * @summary Returns a printable POS PDF
     * @param {number} id 
     * @param {PosPrintSizeEnum} size In which size the POS PDF should be rendered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    posPrint(id: number, size: PosPrintSizeEnum, options?: AxiosRequestConfig): AxiosPromise<File>;

    /**
     * Returns a list of emails, where the invoice is sent.
     * @summary Send invoice to given email adresses.
     * @param {number} id 
     * @param {SendDocument} [sendDocument] List of email-s where you want to send the invoice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    sendDocument(id: number, sendDocument?: SendDocument, options?: AxiosRequestConfig): AxiosPromise<SendDocument>;

    /**
     * Update payment history an existing document. Returns a payment history object if the update is succeded.
     * @summary Update payment history
     * @param {number} id 
     * @param {Array<PaymentHistory>} paymentHistory Payment history object that you would like to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApiInterface
     */
    updatePayment(id: number, paymentHistory: Array<PaymentHistory>, options?: AxiosRequestConfig): AxiosPromise<Array<PaymentHistory>>;

}

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI implements DocumentApiInterface {
    /**
     * Archive an existing proforma document.
     * @summary Archive a proforma document.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public archiveDocument(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).archiveDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel a document. Returns a cancellation document object if the cancellation is succeded.
     * @summary Cancel a document
     * @param {number} id 
     * @param {DocumentCancellation} [documentCancellation] Comment and notifiable email addresses - comma separated for multiple email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public cancelDocument(id: number, documentCancellation?: DocumentCancellation, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).cancelDocument(id, documentCancellation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document. Returns a document object if the create is succeded.
     * @summary Create a document
     * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createDocument(documentInsert: DocumentInsert, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).createDocument(documentInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts a draft to an invoice. Returns the invoice object if the convert is succeded.
     * @summary Converts a draft to an invoice.
     * @param {number} id 
     * @param {DocumentInsert} documentInsert DocumentInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createDocumentFromDraft(id: number, documentInsert: DocumentInsert, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).createDocumentFromDraft(id, documentInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new document from proforma. Returns a document object if the create is succeded.
     * @summary Create a document from proforma.
     * @param {number} id 
     * @param {InvoiceSettings} [invoiceSettings] InvoiceSettings object.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createDocumentFromProforma(id: number, invoiceSettings?: InvoiceSettings, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).createDocumentFromProforma(id, invoiceSettings, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a modification document for the given document. Returns a new document object if the create is successful.
     * @summary Create a modification document.
     * @param {number} id 
     * @param {ModificationDocumentInsert} modificationDocumentInsert ModificationDocumentInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createModificationDocument(id: number, modificationDocumentInsert: ModificationDocumentInsert, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).createModificationDocument(id, modificationDocumentInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new receipt. Returns a document object if the create is succeded.
     * @summary Create a receipt
     * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createReceipt(receiptInsert: ReceiptInsert, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).createReceipt(receiptInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Converts a draft to a receipt. Returns the receipt object if the convert is succeded.
     * @summary Converts a draft to a receipt.
     * @param {number} id 
     * @param {ReceiptInsert} receiptInsert ReceiptInsert object that you would like to store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public createReceiptFromDraft(id: number, receiptInsert: ReceiptInsert, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).createReceiptFromDraft(id, receiptInsert, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an existing draft.
     * @summary Delete a draft.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDocument(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).deleteDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all exist payment history on document.
     * @summary Delete all payment history on document
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deletePayment(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).deletePayment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Copy a document. Returns the new document if the copy was succeded.
     * @summary Copy a document
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public documentCopy(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).documentCopy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download a document. Returns a document in PDF format.
     * @summary Download a document in PDF format.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public downloadDocument(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).downloadDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing document.
     * @summary Retrieve a document
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocument(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).getDocument(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing document by vendor id.
     * @summary Retrieve a document by vendor id
     * @param {string} vendorId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocumentByVendorId(vendorId: string, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).getDocumentByVendorId(vendorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of an existing document status.
     * @summary Retrieve a document Online Sz√°mla status
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getOnlineSzamlaStatus(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).getOnlineSzamlaStatus(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the details of payment history an existing document.
     * @summary Retrieve a payment histroy
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getPayment(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).getPayment(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves public url to download an existing document.
     * @summary Retrieve a document download public url.
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getPublicUrl(id: number, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).getPublicUrl(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of your documents. The documents are returned sorted by creation date, with the most recent documents appearing first.
     * @summary List all documents
     * @param {number} [page] 
     * @param {number} [perPage] 
     * @param {number} [blockId] Filter documents by the identifier of your DocumentBlock.
     * @param {number} [partnerId] Filter documents by the identifier of your Partner.
     * @param {PaymentMethod} [paymentMethod] Filter documents by PaymentMethod value.
     * @param {PaymentStatus} [paymentStatus] Filter documents by PaymentStatus value.
     * @param {string} [startDate] Filter documents by their invoice date.
     * @param {string} [endDate] Filter documents by their invoice date.
     * @param {number} [startNumber] Starting number of the document, should not contain year or any other formatting. Required if &#x60;start_year&#x60; given
     * @param {number} [endNumber] Ending number of the document, should not contain year or any other formatting. Required if &#x60;end_year&#x60; given
     * @param {number} [startYear] Year for &#x60;start_number&#x60; parameter. Required if &#x60;start_number&#x60; given.
     * @param {number} [endYear] Year for &#x60;end_number&#x60; parameter. Required if &#x60;end_number&#x60; given.
     * @param {DocumentType} [type] Filter documents by type
     * @param {string} [query] Filter documents by the given text
     * @param {string} [paidStartDate] Filter documents by their payment date.
     * @param {string} [paidEndDate] Filter documents by their payment date.
     * @param {string} [fulfillmentStartDate] Filter documents by their fulfillment date.
     * @param {string} [fulfillmentEndDate] Filter documents by their fulfillment date.
     * @param {string} [lastModifiedDate] Filter documents by their last modified date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public listDocument(page?: number, perPage?: number, blockId?: number, partnerId?: number, paymentMethod?: PaymentMethod, paymentStatus?: PaymentStatus, startDate?: string, endDate?: string, startNumber?: number, endNumber?: number, startYear?: number, endYear?: number, type?: DocumentType, query?: string, paidStartDate?: string, paidEndDate?: string, fulfillmentStartDate?: string, fulfillmentEndDate?: string, lastModifiedDate?: string, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).listDocument(page, perPage, blockId, partnerId, paymentMethod, paymentStatus, startDate, endDate, startNumber, endNumber, startYear, endYear, type, query, paidStartDate, paidEndDate, fulfillmentStartDate, fulfillmentEndDate, lastModifiedDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a printable POS PDF file of a particular document.
     * @summary Returns a printable POS PDF
     * @param {number} id 
     * @param {PosPrintSizeEnum} size In which size the POS PDF should be rendered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public posPrint(id: number, size: PosPrintSizeEnum, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).posPrint(id, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of emails, where the invoice is sent.
     * @summary Send invoice to given email adresses.
     * @param {number} id 
     * @param {SendDocument} [sendDocument] List of email-s where you want to send the invoice.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public sendDocument(id: number, sendDocument?: SendDocument, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).sendDocument(id, sendDocument, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update payment history an existing document. Returns a payment history object if the update is succeded.
     * @summary Update payment history
     * @param {number} id 
     * @param {Array<PaymentHistory>} paymentHistory Payment history object that you would like to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updatePayment(id: number, paymentHistory: Array<PaymentHistory>, options?: AxiosRequestConfig) {
        return DocumentApiFp(this.configuration).updatePayment(id, paymentHistory, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PosPrintSizeEnum = {
    NUMBER_58: 58,
    NUMBER_80: 80
} as const;
export type PosPrintSizeEnum = typeof PosPrintSizeEnum[keyof typeof PosPrintSizeEnum];
