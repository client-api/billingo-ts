/* tslint:disable */
/* eslint-disable */
/**
 * Forgejo API.
 * This documentation describes the Forgejo API.
 *
 * The version of the OpenAPI document: 1.20.5+0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddTimeOption } from '../models';
// @ts-ignore
import { Attachment } from '../models';
// @ts-ignore
import { Comment } from '../models';
// @ts-ignore
import { CreateIssueCommentOption } from '../models';
// @ts-ignore
import { CreateIssueOption } from '../models';
// @ts-ignore
import { CreateLabelOption } from '../models';
// @ts-ignore
import { CreateMilestoneOption } from '../models';
// @ts-ignore
import { EditAttachmentOptions } from '../models';
// @ts-ignore
import { EditDeadlineOption } from '../models';
// @ts-ignore
import { EditIssueCommentOption } from '../models';
// @ts-ignore
import { EditIssueOption } from '../models';
// @ts-ignore
import { EditLabelOption } from '../models';
// @ts-ignore
import { EditMilestoneOption } from '../models';
// @ts-ignore
import { EditReactionOption } from '../models';
// @ts-ignore
import { Issue } from '../models';
// @ts-ignore
import { IssueDeadline } from '../models';
// @ts-ignore
import { IssueLabelsOption } from '../models';
// @ts-ignore
import { IssueMeta } from '../models';
// @ts-ignore
import { Label } from '../models';
// @ts-ignore
import { Milestone } from '../models';
// @ts-ignore
import { Reaction } from '../models';
// @ts-ignore
import { TimelineComment } from '../models';
// @ts-ignore
import { TrackedTime } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { WatchInfo } from '../models';
/**
 * IssueApi - axios parameter creator
 * @export
 */
export const IssueApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddLabel: async (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddLabel', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddLabel', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddSubscription: async (owner: string, repo: string, index: number, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddSubscription', 'index', index)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('issueAddSubscription', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddTime: async (owner: string, repo: string, index: number, body?: AddTimeOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueAddTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueAddTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueAddTime', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCheckSubscription: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCheckSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCheckSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCheckSubscription', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/check`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueClearLabels: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueClearLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueClearLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueClearLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateComment: async (owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateComment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateComment', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssue: async (owner: string, repo: string, body?: CreateIssueOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssue', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueAttachment: async (owner: string, repo: string, index: number, attachment: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'index', index)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('issueCreateIssueAttachment', 'attachment', attachment)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Block the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueBlocking: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueBlocking', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueBlocking', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateIssueBlocking', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/blocks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueCommentAttachment: async (owner: string, repo: string, id: number, attachment: File, name?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachment' is not null or undefined
            assertParamExists('issueCreateIssueCommentAttachment', 'attachment', attachment)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


            if (attachment !== undefined) { 
                localVarFormParams.append('attachment', attachment as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Make the issue in the url depend on the issue in the form.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueDependencies: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateIssueDependencies', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateIssueDependencies', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueCreateIssueDependencies', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/dependencies`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateLabel: async (owner: string, repo: string, body?: CreateLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateLabel', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateMilestone: async (owner: string, repo: string, body?: CreateMilestoneOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueCreateMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueCreateMilestone', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/milestones`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDelete: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDelete', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDelete', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDelete', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteComment: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueDeleteCommentDeprecated: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteCommentDeprecated', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteCommentReaction: async (owner: string, repo: string, id: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteCommentReaction', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueAttachment: async (owner: string, repo: string, index: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'index', index)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueDeleteIssueAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueCommentAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueDeleteIssueCommentAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueReaction: async (owner: string, repo: string, index: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteIssueReaction', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteLabel: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteMilestone: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/delete`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteSubscription: async (owner: string, repo: string, index: number, user: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'index', index)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('issueDeleteSubscription', 'user', user)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions/{user}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteTime: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueDeleteTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueDeleteTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueDeleteTime', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueDeleteTime', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditComment: async (owner: string, repo: string, id: number, body?: EditIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueEditCommentDeprecated: async (owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditCommentDeprecated', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssue: async (owner: string, repo: string, index: number, body?: EditIssueOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueAttachment: async (owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'index', index)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueEditIssueAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edit a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueCommentAttachment: async (owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueEditIssueCommentAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueDeadline: async (owner: string, repo: string, index: number, body?: EditDeadlineOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueEditIssueDeadline', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/deadline`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditLabel: async (owner: string, repo: string, id: number, body?: EditLabelOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditMilestone: async (owner: string, repo: string, id: string, body?: EditMilestoneOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueEditMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueEditMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueEditMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComment: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetComment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetComment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetComment', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentReactions: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetCommentReactions', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComments: async (owner: string, repo: string, index: number, since?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetComments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetComments', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentsAndTimeline: async (owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetCommentsAndTimeline', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/timeline`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssue: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueAttachment: async (owner: string, repo: string, index: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'index', index)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueGetIssueAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueCommentAttachment: async (owner: string, repo: string, id: number, attachmentId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'id', id)
            // verify required parameter 'attachmentId' is not null or undefined
            assertParamExists('issueGetIssueCommentAttachment', 'attachmentId', attachmentId)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachment_id"}}`, encodeURIComponent(String(attachmentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueReactions: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetIssueReactions', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabel: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetLabel', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabels: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueGetLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestone: async (owner: string, repo: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetMilestone', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetMilestone', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueGetMilestone', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/milestones/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestonesList: async (owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetMilestonesList', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetMilestonesList', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/milestones`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetRepoComments: async (owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueGetRepoComments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueGetRepoComments', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List issues that are blocked by this issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListBlocks: async (owner: string, repo: string, index: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListBlocks', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListBlocks', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueListBlocks', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/blocks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List issue\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueAttachments: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssueAttachments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssueAttachments', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueListIssueAttachments', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List comment\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueCommentAttachments: async (owner: string, repo: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssueCommentAttachments', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssueCommentAttachments', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueListIssueCommentAttachments', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/assets`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an issue\'s dependencies, i.e all issues that block this issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueDependencies: async (owner: string, repo: string, index: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssueDependencies', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssueDependencies', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueListIssueDependencies', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/dependencies`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssues: async (owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListIssues', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListIssues', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/issues`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (milestones !== undefined) {
                localVarQueryParameter['milestones'] = milestones;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (createdBy !== undefined) {
                localVarQueryParameter['created_by'] = createdBy;
            }

            if (assignedBy !== undefined) {
                localVarQueryParameter['assigned_by'] = assignedBy;
            }

            if (mentionedBy !== undefined) {
                localVarQueryParameter['mentioned_by'] = mentionedBy;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListLabels: async (owner: string, repo: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueListLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueListLabels', 'repo', repo)
            const localVarPath = `/repos/{owner}/{repo}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostCommentReaction: async (owner: string, repo: string, id: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'repo', repo)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issuePostCommentReaction', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/comments/{id}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostIssueReaction: async (owner: string, repo: string, index: number, content?: EditReactionOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issuePostIssueReaction', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/reactions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(content, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unblock the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueBlocking: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueRemoveIssueBlocking', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueRemoveIssueBlocking', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueRemoveIssueBlocking', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/blocks`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an issue dependency
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueDependencies: async (owner: string, repo: string, index: string, body?: IssueMeta, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueRemoveIssueDependencies', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueRemoveIssueDependencies', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueRemoveIssueDependencies', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/dependencies`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveLabel: async (owner: string, repo: string, index: number, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueRemoveLabel', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueRemoveLabel', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueRemoveLabel', 'index', index)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('issueRemoveLabel', 'id', id)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels/{id}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueReplaceLabels: async (owner: string, repo: string, index: number, body?: IssueLabelsOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueReplaceLabels', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueReplaceLabels', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueReplaceLabels', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/labels`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueResetTime: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueResetTime', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueResetTime', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueResetTime', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSearchIssues: async (state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/repos/issues/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (labels !== undefined) {
                localVarQueryParameter['labels'] = labels;
            }

            if (milestones !== undefined) {
                localVarQueryParameter['milestones'] = milestones;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (priorityRepoId !== undefined) {
                localVarQueryParameter['priority_repo_id'] = priorityRepoId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (mentioned !== undefined) {
                localVarQueryParameter['mentioned'] = mentioned;
            }

            if (reviewRequested !== undefined) {
                localVarQueryParameter['review_requested'] = reviewRequested;
            }

            if (reviewed !== undefined) {
                localVarQueryParameter['reviewed'] = reviewed;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (team !== undefined) {
                localVarQueryParameter['team'] = team;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStartStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueStartStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueStartStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueStartStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/start`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStopStopWatch: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueStopStopWatch', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueStopStopWatch', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueStopStopWatch', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/stopwatch/stop`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriptions: async (owner: string, repo: string, index: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueSubscriptions', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueSubscriptions', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueSubscriptions', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/subscriptions`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTrackedTimes: async (owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('issueTrackedTimes', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('issueTrackedTimes', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('issueTrackedTimes', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/times`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Moves the Pin to the given Position
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue
         * @param {number} position the new position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveIssuePin: async (owner: string, repo: string, index: number, position: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('moveIssuePin', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('moveIssuePin', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('moveIssuePin', 'index', index)
            // verify required parameter 'position' is not null or undefined
            assertParamExists('moveIssuePin', 'position', position)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/pin/{position}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)))
                .replace(`{${"position"}}`, encodeURIComponent(String(position)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinIssue: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('pinIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('pinIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('pinIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/pin`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unpin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to unpin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinIssue: async (owner: string, repo: string, index: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('unpinIssue', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('unpinIssue', 'repo', repo)
            // verify required parameter 'index' is not null or undefined
            assertParamExists('unpinIssue', 'index', index)
            const localVarPath = `/repos/{owner}/{repo}/issues/{index}/pin`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)))
                .replace(`{${"index"}}`, encodeURIComponent(String(index)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IssueApi - functional programming interface
 * @export
 */
export const IssueApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IssueApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddLabel(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddSubscription(owner, repo, index, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrackedTime>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueAddTime(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCheckSubscription(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WatchInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCheckSubscription(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueClearLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueClearLabels(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateComment(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssue(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueAttachment(owner, repo, index, attachment, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Block the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueBlocking(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueCommentAttachment(owner, repo, id, attachment, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Make the issue in the url depend on the issue in the form.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateIssueDependencies(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateLabel(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueCreateMilestone(owner, repo, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDelete(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDelete(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteComment(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteCommentDeprecated(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteCommentReaction(owner, repo, id, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteIssueAttachment(owner, repo, index, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteIssueCommentAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteIssueReaction(owner, repo, index, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteLabel(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteMilestone(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteSubscription(owner, repo, index, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueDeleteTime(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditComment(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditCommentDeprecated(owner, repo, index, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssue(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssueAttachment(owner, repo, index, attachmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Edit a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssueCommentAttachment(owner, repo, id, attachmentId, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IssueDeadline>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditIssueDeadline(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditLabel(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueEditMilestone(owner, repo, id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Comment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetComment(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetCommentReactions(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetCommentReactions(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetComments(owner, repo, index, since, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TimelineComment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssue(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssueAttachment(owner, repo, index, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Attachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssueCommentAttachment(owner, repo, id, attachmentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetIssueReactions(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Label>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetLabel(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetLabels(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Milestone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetMilestone(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Milestone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetMilestonesList(owner, repo, state, name, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueGetRepoComments(owner, repo, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List issues that are blocked by this issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListBlocks(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List issue\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssueAttachments(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssueAttachments(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List comment\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Attachment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssueCommentAttachments(owner, repo, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an issue\'s dependencies, i.e all issues that block this issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssueDependencies(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueListLabels(owner, repo, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePostCommentReaction(owner, repo, id, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issuePostIssueReaction(owner, repo, index, content, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unblock the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRemoveIssueBlocking(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove an issue dependency
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Issue>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRemoveIssueDependencies(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueRemoveLabel(owner, repo, index, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Label>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueReplaceLabels(owner, repo, index, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueResetTime(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueResetTime(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Issue>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, reviewed, owner, team, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueStartStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueStartStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueStopStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueStopStopWatch(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueSubscriptions(owner, repo, index, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Moves the Pin to the given Position
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue
         * @param {number} position the new position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveIssuePin(owner: string, repo: string, index: number, position: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveIssuePin(owner, repo, index, position, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinIssue(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unpin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to unpin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unpinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unpinIssue(owner, repo, index, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IssueApi - factory interface
 * @export
 */
export const IssueApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IssueApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a label to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueAddLabel(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Subscribe user to issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user to subscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueAddSubscription(owner, repo, index, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add tracked time to a issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {AddTimeOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: any): AxiosPromise<TrackedTime> {
            return localVarFp.issueAddTime(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if user is subscribed to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCheckSubscription(owner: string, repo: string, index: number, options?: any): AxiosPromise<WatchInfo> {
            return localVarFp.issueCheckSubscription(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove all labels from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueClearLabels(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueClearLabels(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a comment to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {CreateIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueCreateComment(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueCreateIssue(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueCreateIssueAttachment(owner, repo, index, attachment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Block the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueCreateIssueBlocking(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {File} attachment attachment to upload
         * @param {string} [name] name of the attachment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueCreateIssueCommentAttachment(owner, repo, id, attachment, name, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Make the issue in the url depend on the issue in the form.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueCreateIssueDependencies(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.issueCreateLabel(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {CreateMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueCreateMilestone(owner, repo, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDelete(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDelete(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteComment(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteComment(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of comment to delete
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteCommentDeprecated(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a reaction from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteCommentReaction(owner, repo, id, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a reaction from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteIssueReaction(owner, repo, index, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteLabel(owner: string, repo: string, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteLabel(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to delete, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteMilestone(owner: string, repo: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteMilestone(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unsubscribe user from issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} user user witch unsubscribe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteSubscription(owner, repo, index, user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete specific tracked time
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of time to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueDeleteTime(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueEditComment(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index this parameter is ignored
         * @param {number} id id of the comment to edit
         * @param {EditIssueCommentOption} [body] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueEditCommentDeprecated(owner, repo, index, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to edit
         * @param {EditIssueOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueEditIssue(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueEditIssueAttachment(owner, repo, index, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edit a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to edit
         * @param {EditAttachmentOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueEditIssueCommentAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create or update a deadline on
         * @param {EditDeadlineOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: any): AxiosPromise<IssueDeadline> {
            return localVarFp.issueEditIssueDeadline(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to edit
         * @param {EditLabelOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: any): AxiosPromise<Label> {
            return localVarFp.issueEditLabel(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to edit, identified by ID and if not available by name
         * @param {EditMilestoneOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueEditMilestone(owner, repo, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a comment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComment(owner: string, repo: string, id: number, options?: any): AxiosPromise<Comment> {
            return localVarFp.issueGetComment(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list of reactions from a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentReactions(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.issueGetCommentReactions(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.issueGetComments(owner, repo, index, since, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments and events on an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [since] if provided, only comments updated since the specified time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: any): AxiosPromise<Array<TimelineComment>> {
            return localVarFp.issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssue(owner: string, repo: string, index: number, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueGetIssue(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueGetIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a comment attachment
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {number} attachmentId id of the attachment to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: any): AxiosPromise<Attachment> {
            return localVarFp.issueGetIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a list reactions of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<Reaction>> {
            return localVarFp.issueGetIssueReactions(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a single label
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the label to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabel(owner: string, repo: string, id: number, options?: any): AxiosPromise<Label> {
            return localVarFp.issueGetLabel(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetLabels(owner: string, repo: string, index: number, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueGetLabels(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a milestone
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} id the milestone to get, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestone(owner: string, repo: string, id: string, options?: any): AxiosPromise<Milestone> {
            return localVarFp.issueGetMilestone(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all of a repository\'s opened milestones
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
         * @param {string} [name] filter by milestone name
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Milestone>> {
            return localVarFp.issueGetMilestonesList(owner, repo, state, name, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all comments in a repository
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} [since] if provided, only comments updated since the provided time are returned.
         * @param {string} [before] if provided, only comments updated before the provided time are returned.
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Comment>> {
            return localVarFp.issueGetRepoComments(owner, repo, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List issues that are blocked by this issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueListBlocks(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List issue\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueAttachments(owner: string, repo: string, index: number, options?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.issueListIssueAttachments(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List comment\'s attachments
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: any): AxiosPromise<Array<Attachment>> {
            return localVarFp.issueListIssueCommentAttachments(owner, repo, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an issue\'s dependencies, i.e all issues that block this issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueListIssueDependencies(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a repository\'s issues
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [q] search string
         * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
         * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
         * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
         * @param {string} [createdBy] Only show items which were created by the the given user
         * @param {string} [assignedBy] Only show items for which the given user is assigned
         * @param {string} [mentionedBy] Only show items in which the given user was mentioned
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all of a repository\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueListLabels(owner, repo, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a reaction to a comment of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} id id of the comment to edit
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: any): AxiosPromise<Reaction> {
            return localVarFp.issuePostCommentReaction(owner, repo, id, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add a reaction to an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {EditReactionOption} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: any): AxiosPromise<Reaction> {
            return localVarFp.issuePostIssueReaction(owner, repo, index, content, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unblock the issue given in the body by the issue in path
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueRemoveIssueBlocking(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an issue dependency
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {string} index index of the issue
         * @param {IssueMeta} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: any): AxiosPromise<Issue> {
            return localVarFp.issueRemoveIssueDependencies(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a label from an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} id id of the label to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueRemoveLabel(owner, repo, index, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Replace an issue\'s labels
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {IssueLabelsOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: any): AxiosPromise<Array<Label>> {
            return localVarFp.issueReplaceLabels(owner, repo, index, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset a tracked time of an issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to add tracked time to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueResetTime(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueResetTime(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for issues across the repositories that the user has access to
         * @param {string} [state] whether issue is open or closed
         * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
         * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
         * @param {string} [q] search string
         * @param {number} [priorityRepoId] repository to prioritize in the results
         * @param {string} [type] filter by type (issues / pulls) if set
         * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
         * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
         * @param {boolean} [created] filter (issues / pulls) created by you, default is false
         * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
         * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
         * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
         * @param {string} [owner] filter by owner
         * @param {string} [team] filter by team (requires organization owner parameter to be provided)
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Issue>> {
            return localVarFp.issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, reviewed, owner, team, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Start stopwatch on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to create the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStartStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueStartStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stop an issue\'s existing stopwatch.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue to stop the stopwatch on
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueStopStopWatch(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.issueStopStopWatch(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get users who subscribed on an issue.
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.issueSubscriptions(owner, repo, index, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List an issue\'s tracked times
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of the issue
         * @param {string} [user] optional filter by user (available for issue managers)
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Moves the Pin to the given Position
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue
         * @param {number} position the new position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveIssuePin(owner: string, repo: string, index: number, position: number, options?: any): AxiosPromise<void> {
            return localVarFp.moveIssuePin(owner, repo, index, position, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinIssue(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.pinIssue(owner, repo, index, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unpin an Issue
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {number} index index of issue to unpin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unpinIssue(owner: string, repo: string, index: number, options?: any): AxiosPromise<void> {
            return localVarFp.unpinIssue(owner, repo, index, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IssueApi - interface
 * @export
 * @interface IssueApi
 */
export interface IssueApiInterface {
    /**
     * 
     * @summary Add a label to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Subscribe user to issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user to subscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add tracked time to a issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {AddTimeOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: AxiosRequestConfig): AxiosPromise<TrackedTime>;

    /**
     * 
     * @summary Check if user is subscribed to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCheckSubscription(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<WatchInfo>;

    /**
     * 
     * @summary Remove all labels from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueClearLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Add a comment to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {CreateIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Create an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Block the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Create a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Make the issue in the url depend on the issue in the form.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Create a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Create a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: AxiosRequestConfig): AxiosPromise<Milestone>;

    /**
     * 
     * @summary Delete an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDelete(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a reaction from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a reaction from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to delete, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unsubscribe user from issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user witch unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete specific tracked time
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of time to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to edit
     * @param {EditIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Edit an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Edit a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create or update a deadline on
     * @param {EditDeadlineOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: AxiosRequestConfig): AxiosPromise<IssueDeadline>;

    /**
     * 
     * @summary Update a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to edit
     * @param {EditLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Update a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to edit, identified by ID and if not available by name
     * @param {EditMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: AxiosRequestConfig): AxiosPromise<Milestone>;

    /**
     * 
     * @summary Get a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Comment>;

    /**
     * 
     * @summary Get a list of reactions from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetCommentReactions(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<Reaction>>;

    /**
     * 
     * @summary List all comments on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: AxiosRequestConfig): AxiosPromise<Array<Comment>>;

    /**
     * 
     * @summary List all comments and events on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: AxiosRequestConfig): AxiosPromise<Array<TimelineComment>>;

    /**
     * 
     * @summary Get an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Get an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Get a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig): AxiosPromise<Attachment>;

    /**
     * 
     * @summary Get a list reactions of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Reaction>>;

    /**
     * 
     * @summary Get a single label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Label>;

    /**
     * 
     * @summary Get an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Get a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to get, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig): AxiosPromise<Milestone>;

    /**
     * 
     * @summary Get all of a repository\'s opened milestones
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
     * @param {string} [name] filter by milestone name
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Milestone>>;

    /**
     * 
     * @summary List all comments in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [since] if provided, only comments updated since the provided time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Comment>>;

    /**
     * 
     * @summary List issues that are blocked by this issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary List issue\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssueAttachments(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<Array<Attachment>>;

    /**
     * 
     * @summary List comment\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig): AxiosPromise<Array<Attachment>>;

    /**
     * 
     * @summary List an issue\'s dependencies, i.e all issues that block this issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary List a repository\'s issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [q] search string
     * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
     * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
     * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
     * @param {string} [createdBy] Only show items which were created by the the given user
     * @param {string} [assignedBy] Only show items for which the given user is assigned
     * @param {string} [mentionedBy] Only show items in which the given user was mentioned
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary Get all of a repository\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Add a reaction to a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<Reaction>;

    /**
     * 
     * @summary Add a reaction to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig): AxiosPromise<Reaction>;

    /**
     * 
     * @summary Unblock the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Remove an issue dependency
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig): AxiosPromise<Issue>;

    /**
     * 
     * @summary Remove a label from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of the label to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Replace an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig): AxiosPromise<Array<Label>>;

    /**
     * 
     * @summary Reset a tracked time of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to add tracked time to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueResetTime(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Search for issues across the repositories that the user has access to
     * @param {string} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
     * @param {string} [q] search string
     * @param {number} [priorityRepoId] repository to prioritize in the results
     * @param {string} [type] filter by type (issues / pulls) if set
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
     * @param {boolean} [created] filter (issues / pulls) created by you, default is false
     * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
     * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
     * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
     * @param {string} [owner] filter by owner
     * @param {string} [team] filter by team (requires organization owner parameter to be provided)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Issue>>;

    /**
     * 
     * @summary Start stopwatch on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueStartStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Stop an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueStopStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get users who subscribed on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List an issue\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

    /**
     * 
     * @summary Moves the Pin to the given Position
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue
     * @param {number} position the new position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    moveIssuePin(owner: string, repo: string, index: number, position: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Pin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to pin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    pinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unpin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to unpin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApiInterface
     */
    unpinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig): AxiosPromise<void>;

}

/**
 * IssueApi - object-oriented interface
 * @export
 * @class IssueApi
 * @extends {BaseAPI}
 */
export class IssueApi extends BaseAPI implements IssueApiInterface {
    /**
     * 
     * @summary Add a label to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddLabel(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddLabel(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Subscribe user to issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user to subscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddSubscription(owner, repo, index, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add tracked time to a issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {AddTimeOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueAddTime(owner: string, repo: string, index: number, body?: AddTimeOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueAddTime(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if user is subscribed to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCheckSubscription(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCheckSubscription(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove all labels from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueClearLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueClearLabels(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a comment to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {CreateIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateComment(owner: string, repo: string, index: number, body?: CreateIssueCommentOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateComment(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssue(owner: string, repo: string, body?: CreateIssueOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssue(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueAttachment(owner: string, repo: string, index: number, attachment: File, name?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueAttachment(owner, repo, index, attachment, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Block the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueBlocking(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {File} attachment attachment to upload
     * @param {string} [name] name of the attachment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueCommentAttachment(owner: string, repo: string, id: number, attachment: File, name?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueCommentAttachment(owner, repo, id, attachment, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Make the issue in the url depend on the issue in the form.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateIssueDependencies(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateLabel(owner: string, repo: string, body?: CreateLabelOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateLabel(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {CreateMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueCreateMilestone(owner: string, repo: string, body?: CreateMilestoneOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueCreateMilestone(owner, repo, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDelete(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDelete(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteComment(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of comment to delete
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteCommentDeprecated(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteCommentDeprecated(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a reaction from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteCommentReaction(owner, repo, id, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a reaction from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteIssueReaction(owner, repo, index, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteLabel(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to delete, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteMilestone(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteStopWatch(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unsubscribe user from issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} user user witch unsubscribe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteSubscription(owner: string, repo: string, index: number, user: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteSubscription(owner, repo, index, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete specific tracked time
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of time to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueDeleteTime(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueDeleteTime(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditComment(owner: string, repo: string, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditComment(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index this parameter is ignored
     * @param {number} id id of the comment to edit
     * @param {EditIssueCommentOption} [body] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditCommentDeprecated(owner: string, repo: string, index: number, id: number, body?: EditIssueCommentOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditCommentDeprecated(owner, repo, index, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to edit
     * @param {EditIssueOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssue(owner: string, repo: string, index: number, body?: EditIssueOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssue(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssueAttachment(owner, repo, index, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edit a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to edit
     * @param {EditAttachmentOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, body?: EditAttachmentOptions, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssueCommentAttachment(owner, repo, id, attachmentId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create or update a deadline on
     * @param {EditDeadlineOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditIssueDeadline(owner: string, repo: string, index: number, body?: EditDeadlineOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditIssueDeadline(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to edit
     * @param {EditLabelOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditLabel(owner: string, repo: string, id: number, body?: EditLabelOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditLabel(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to edit, identified by ID and if not available by name
     * @param {EditMilestoneOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueEditMilestone(owner: string, repo: string, id: string, body?: EditMilestoneOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueEditMilestone(owner, repo, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a comment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetComment(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetComment(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list of reactions from a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetCommentReactions(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetCommentReactions(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetComments(owner: string, repo: string, index: number, since?: string, before?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetComments(owner, repo, index, since, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments and events on an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [since] if provided, only comments updated since the specified time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetCommentsAndTimeline(owner: string, repo: string, index: number, since?: string, page?: number, limit?: number, before?: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetCommentsAndTimeline(owner, repo, index, since, page, limit, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssue(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssueAttachment(owner: string, repo: string, index: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssueAttachment(owner, repo, index, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a comment attachment
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {number} attachmentId id of the attachment to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssueCommentAttachment(owner: string, repo: string, id: number, attachmentId: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssueCommentAttachment(owner, repo, id, attachmentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a list reactions of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetIssueReactions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetIssueReactions(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a single label
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the label to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetLabel(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetLabel(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetLabels(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetLabels(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a milestone
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} id the milestone to get, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetMilestone(owner: string, repo: string, id: string, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetMilestone(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all of a repository\'s opened milestones
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [state] Milestone state, Recognized values are open, closed and all. Defaults to \&quot;open\&quot;
     * @param {string} [name] filter by milestone name
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetMilestonesList(owner: string, repo: string, state?: string, name?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetMilestonesList(owner, repo, state, name, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all comments in a repository
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} [since] if provided, only comments updated since the provided time are returned.
     * @param {string} [before] if provided, only comments updated before the provided time are returned.
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueGetRepoComments(owner: string, repo: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueGetRepoComments(owner, repo, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List issues that are blocked by this issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListBlocks(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListBlocks(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List issue\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssueAttachments(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssueAttachments(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List comment\'s attachments
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssueCommentAttachments(owner: string, repo: string, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssueCommentAttachments(owner, repo, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an issue\'s dependencies, i.e all issues that block this issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssueDependencies(owner: string, repo: string, index: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssueDependencies(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a repository\'s issues
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {IssueListIssuesStateEnum} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [q] search string
     * @param {IssueListIssuesTypeEnum} [type] filter by type (issues / pulls) if set
     * @param {string} [milestones] comma separated list of milestone names or ids. It uses names and fall back to ids. Fetch only issues that have any of this milestones. Non existent milestones are discarded
     * @param {string} [since] Only show items updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show items updated before the given time. This is a timestamp in RFC 3339 format
     * @param {string} [createdBy] Only show items which were created by the the given user
     * @param {string} [assignedBy] Only show items for which the given user is assigned
     * @param {string} [mentionedBy] Only show items in which the given user was mentioned
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListIssues(owner: string, repo: string, state?: IssueListIssuesStateEnum, labels?: string, q?: string, type?: IssueListIssuesTypeEnum, milestones?: string, since?: string, before?: string, createdBy?: string, assignedBy?: string, mentionedBy?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListIssues(owner, repo, state, labels, q, type, milestones, since, before, createdBy, assignedBy, mentionedBy, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all of a repository\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueListLabels(owner: string, repo: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueListLabels(owner, repo, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a reaction to a comment of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} id id of the comment to edit
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issuePostCommentReaction(owner: string, repo: string, id: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issuePostCommentReaction(owner, repo, id, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add a reaction to an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {EditReactionOption} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issuePostIssueReaction(owner: string, repo: string, index: number, content?: EditReactionOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issuePostIssueReaction(owner, repo, index, content, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unblock the issue given in the body by the issue in path
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueRemoveIssueBlocking(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueRemoveIssueBlocking(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an issue dependency
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {string} index index of the issue
     * @param {IssueMeta} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueRemoveIssueDependencies(owner: string, repo: string, index: string, body?: IssueMeta, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueRemoveIssueDependencies(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a label from an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} id id of the label to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueRemoveLabel(owner: string, repo: string, index: number, id: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueRemoveLabel(owner, repo, index, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Replace an issue\'s labels
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {IssueLabelsOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueReplaceLabels(owner: string, repo: string, index: number, body?: IssueLabelsOption, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueReplaceLabels(owner, repo, index, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset a tracked time of an issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to add tracked time to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueResetTime(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueResetTime(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for issues across the repositories that the user has access to
     * @param {string} [state] whether issue is open or closed
     * @param {string} [labels] comma separated list of labels. Fetch only issues that have any of this labels. Non existent labels are discarded
     * @param {string} [milestones] comma separated list of milestone names. Fetch only issues that have any of this milestones. Non existent are discarded
     * @param {string} [q] search string
     * @param {number} [priorityRepoId] repository to prioritize in the results
     * @param {string} [type] filter by type (issues / pulls) if set
     * @param {string} [since] Only show notifications updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show notifications updated before the given time. This is a timestamp in RFC 3339 format
     * @param {boolean} [assigned] filter (issues / pulls) assigned to you, default is false
     * @param {boolean} [created] filter (issues / pulls) created by you, default is false
     * @param {boolean} [mentioned] filter (issues / pulls) mentioning you, default is false
     * @param {boolean} [reviewRequested] filter pulls requesting your review, default is false
     * @param {boolean} [reviewed] filter pulls reviewed by you, default is false
     * @param {string} [owner] filter by owner
     * @param {string} [team] filter by team (requires organization owner parameter to be provided)
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueSearchIssues(state?: string, labels?: string, milestones?: string, q?: string, priorityRepoId?: number, type?: string, since?: string, before?: string, assigned?: boolean, created?: boolean, mentioned?: boolean, reviewRequested?: boolean, reviewed?: boolean, owner?: string, team?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueSearchIssues(state, labels, milestones, q, priorityRepoId, type, since, before, assigned, created, mentioned, reviewRequested, reviewed, owner, team, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Start stopwatch on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to create the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueStartStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueStartStopWatch(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stop an issue\'s existing stopwatch.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue to stop the stopwatch on
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueStopStopWatch(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueStopStopWatch(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get users who subscribed on an issue.
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueSubscriptions(owner: string, repo: string, index: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueSubscriptions(owner, repo, index, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List an issue\'s tracked times
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of the issue
     * @param {string} [user] optional filter by user (available for issue managers)
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public issueTrackedTimes(owner: string, repo: string, index: number, user?: string, since?: string, before?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).issueTrackedTimes(owner, repo, index, user, since, before, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Moves the Pin to the given Position
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue
     * @param {number} position the new position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public moveIssuePin(owner: string, repo: string, index: number, position: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).moveIssuePin(owner, repo, index, position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to pin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public pinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).pinIssue(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unpin an Issue
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {number} index index of issue to unpin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IssueApi
     */
    public unpinIssue(owner: string, repo: string, index: number, options?: AxiosRequestConfig) {
        return IssueApiFp(this.configuration).unpinIssue(owner, repo, index, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const IssueListIssuesStateEnum = {
    Closed: 'closed',
    Open: 'open',
    All: 'all'
} as const;
export type IssueListIssuesStateEnum = typeof IssueListIssuesStateEnum[keyof typeof IssueListIssuesStateEnum];
/**
 * @export
 */
export const IssueListIssuesTypeEnum = {
    Issues: 'issues',
    Pulls: 'pulls'
} as const;
export type IssueListIssuesTypeEnum = typeof IssueListIssuesTypeEnum[keyof typeof IssueListIssuesTypeEnum];
