/* tslint:disable */
/* eslint-disable */
/**
 * Forgejo API.
 * This documentation describes the Forgejo API.
 *
 * The version of the OpenAPI document: 1.20.5+0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AccessToken } from '../models';
// @ts-ignore
import { Activity } from '../models';
// @ts-ignore
import { BlockedUser } from '../models';
// @ts-ignore
import { CreateAccessTokenOption } from '../models';
// @ts-ignore
import { CreateEmailOption } from '../models';
// @ts-ignore
import { CreateGPGKeyOption } from '../models';
// @ts-ignore
import { CreateHookOption } from '../models';
// @ts-ignore
import { CreateKeyOption } from '../models';
// @ts-ignore
import { CreateOAuth2ApplicationOptions } from '../models';
// @ts-ignore
import { CreateRepoOption } from '../models';
// @ts-ignore
import { DeleteEmailOption } from '../models';
// @ts-ignore
import { EditHookOption } from '../models';
// @ts-ignore
import { Email } from '../models';
// @ts-ignore
import { GPGKey } from '../models';
// @ts-ignore
import { Hook } from '../models';
// @ts-ignore
import { OAuth2Application } from '../models';
// @ts-ignore
import { PublicKey } from '../models';
// @ts-ignore
import { Repository } from '../models';
// @ts-ignore
import { StopWatch } from '../models';
// @ts-ignore
import { Team } from '../models';
// @ts-ignore
import { TrackedTime } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { UserHeatmapData } from '../models';
// @ts-ignore
import { UserSearch200Response } from '../models';
// @ts-ignore
import { UserSettings } from '../models';
// @ts-ignore
import { UserSettingsOptions } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo: async (body?: CreateRepoOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationToken: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_key_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings: async (body?: UserSettingsOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddEmail: async (body?: CreateEmailOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Blocks a user from the doer.
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBlockUser: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userBlockUser', 'username', username)
            const localVarPath = `/user/block/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCheckFollowing: async (username: string, target: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCheckFollowing', 'username', username)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('userCheckFollowing', 'target', target)
            const localVarPath = `/users/{username}/following/{target}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateHook: async (body: CreateHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userCreateHook', 'body', body)
            const localVarPath = `/user/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateOAuth2Application: async (body: CreateOAuth2ApplicationOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userCreateOAuth2Application', 'body', body)
            const localVarPath = `/user/applications/oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateToken: async (username: string, body?: CreateAccessTokenOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCreateToken', 'username', username)
            const localVarPath = `/users/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckFollowing: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentCheckFollowing', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckStarring: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentCheckStarring', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentCheckStarring', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteFollow: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentDeleteFollow', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteGPGKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentDeleteGPGKey', 'id', id)
            const localVarPath = `/user/gpg_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentDeleteKey', 'id', id)
            const localVarPath = `/user/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteStar: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentDeleteStar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentDeleteStar', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetGPGKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentGetGPGKey', 'id', id)
            const localVarPath = `/user/gpg_keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetKey: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userCurrentGetKey', 'id', id)
            const localVarPath = `/user/keys/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowers: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowing: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListGPGKeys: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListKeys: async (fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListRepos: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/repos`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListStarred: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/starred`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListSubscriptions: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostGPGKey: async (form?: CreateGPGKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(form, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostKey: async (body?: CreateKeyOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutFollow: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userCurrentPutFollow', 'username', username)
            const localVarPath = `/user/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutStar: async (owner: string, repo: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            assertParamExists('userCurrentPutStar', 'owner', owner)
            // verify required parameter 'repo' is not null or undefined
            assertParamExists('userCurrentPutStar', 'repo', repo)
            const localVarPath = `/user/starred/{owner}/{repo}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"repo"}}`, encodeURIComponent(String(repo)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentTrackedTimes: async (page?: number, limit?: number, since?: string, before?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/times`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any instanceof Date) ?
                    (before as any).toISOString() :
                    before;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAccessToken: async (username: string, token: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userDeleteAccessToken', 'username', username)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('userDeleteAccessToken', 'token', token)
            const localVarPath = `/users/{username}/tokens/{token}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)))
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteEmail: async (body?: DeleteEmailOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteHook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDeleteHook', 'id', id)
            const localVarPath = `/user/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteOAuth2Application: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userDeleteOAuth2Application', 'id', id)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditHook: async (id: number, body?: EditHookOption, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userEditHook', 'id', id)
            const localVarPath = `/user/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGet', 'username', username)
            const localVarPath = `/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetCurrent: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHeatmapData: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGetHeatmapData', 'username', username)
            const localVarPath = `/users/{username}/heatmap`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHook: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetHook', 'id', id)
            const localVarPath = `/user/hooks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOAuth2Application: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userGetOAuth2Application', 'id', id)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOauth2Application: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/applications/oauth2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetStopWatches: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/stopwatches`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetTokens: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userGetTokens', 'username', username)
            const localVarPath = `/users/{username}/tokens`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List a user\'s activity feeds
         * @param {string} username username of user
         * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListActivityFeeds: async (username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListActivityFeeds', 'username', username)
            const localVarPath = `/users/{username}/activities/feeds`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (onlyPerformedBy !== undefined) {
                localVarQueryParameter['only-performed-by'] = onlyPerformedBy;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = (date as any instanceof Date) ?
                    (date as any).toISOString().substring(0,10) :
                    date;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s blocked users
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListBlockedUsers: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/list_blocked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListEmails: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/emails`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowers: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListFollowers', 'username', username)
            const localVarPath = `/users/{username}/followers`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowing: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListFollowing', 'username', username)
            const localVarPath = `/users/{username}/following`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListGPGKeys: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListGPGKeys', 'username', username)
            const localVarPath = `/users/{username}/gpg_keys`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the authenticated user\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListHooks: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/hooks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListKeys: async (username: string, fingerprint?: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListKeys', 'username', username)
            const localVarPath = `/users/{username}/keys`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (fingerprint !== undefined) {
                localVarQueryParameter['fingerprint'] = fingerprint;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListRepos: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListRepos', 'username', username)
            const localVarPath = `/users/{username}/repos`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListStarred: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListStarred', 'username', username)
            const localVarPath = `/users/{username}/starred`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListSubscriptions: async (username: string, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userListSubscriptions', 'username', username)
            const localVarPath = `/users/{username}/subscriptions`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListTeams: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/teams`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch: async (q?: string, uid?: number, page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (uid !== undefined) {
                localVarQueryParameter['uid'] = uid;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Unblocks a user from the doer.
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnblockUser: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userUnblockUser', 'username', username)
            const localVarPath = `/user/unblock/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateOAuth2Application: async (id: number, body: CreateOAuth2ApplicationOptions, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userUpdateOAuth2Application', 'id', id)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('userUpdateOAuth2Application', 'body', body)
            const localVarPath = `/user/applications/oauth2/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifyGPGKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/gpg_key_verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication TOTPHeader required
            await setApiKeyToObject(localVarHeaderParameter, "X-FORGEJO-OTP", configuration)

            // authentication AuthorizationHeaderToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            // authentication SudoHeader required
            await setApiKeyToObject(localVarHeaderParameter, "Sudo", configuration)

            // authentication BasicAuth required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)

            // authentication AccessToken required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            // authentication SudoParam required
            await setApiKeyToObject(localVarQueryParameter, "sudo", configuration)

            // authentication Token required
            await setApiKeyToObject(localVarQueryParameter, "token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Repository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCurrentUserRepo(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSettings(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSettings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserSettings(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVerificationToken(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVerificationToken(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserSettings(body?: UserSettingsOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserSettings>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserSettings(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAddEmail(body?: CreateEmailOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAddEmail(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Blocks a user from the doer.
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBlockUser(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBlockUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCheckFollowing(username: string, target: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCheckFollowing(username, target, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateHook(body: CreateHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateHook(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateOAuth2Application(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCreateToken(username: string, body?: CreateAccessTokenOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCreateToken(username, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckFollowing(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckFollowing(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentCheckStarring(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentCheckStarring(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteFollow(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteFollow(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteGPGKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteGPGKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentDeleteStar(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentDeleteStar(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentGetGPGKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentGetGPGKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentGetKey(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentGetKey(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListFollowers(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListFollowers(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListFollowing(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListFollowing(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListGPGKeys(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GPGKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListGPGKeys(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListKeys(fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListRepos(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListRepos(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListStarred(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListStarred(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentListSubscriptions(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentListSubscriptions(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPostGPGKey(form, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPostKey(body?: CreateKeyOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPostKey(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutFollow(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutFollow(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentPutStar(owner: string, repo: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentPutStar(owner, repo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TrackedTime>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCurrentTrackedTimes(page, limit, since, before, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteAccessToken(username: string, token: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteAccessToken(username, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteEmail(body?: DeleteEmailOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteEmail(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteHook(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteHook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userDeleteOAuth2Application(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userDeleteOAuth2Application(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userEditHook(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGet(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGet(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetCurrent(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetCurrent(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetHeatmapData(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserHeatmapData>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetHeatmapData(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetHook(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Hook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetHook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetOAuth2Application(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetOAuth2Application(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetOauth2Application(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OAuth2Application>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetOauth2Application(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetStopWatches(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StopWatch>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetStopWatches(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userGetTokens(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userGetTokens(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List a user\'s activity feeds
         * @param {string} username username of user
         * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Activity>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListActivityFeeds(username, onlyPerformedBy, date, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s blocked users
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListBlockedUsers(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BlockedUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListBlockedUsers(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListEmails(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Email>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListEmails(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListFollowers(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListFollowers(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListFollowing(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListFollowing(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListGPGKeys(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GPGKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListGPGKeys(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the authenticated user\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListHooks(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Hook>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListHooks(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PublicKey>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListKeys(username, fingerprint, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListRepos(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListRepos(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListStarred(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListStarred(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListSubscriptions(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Repository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListSubscriptions(username, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userListTeams(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Team>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userListTeams(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearch200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearch(q, uid, page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Unblocks a user from the doer.
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUnblockUser(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUnblockUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OAuth2Application>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userUpdateOAuth2Application(id, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userVerifyGPGKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GPGKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userVerifyGPGKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a repository
         * @param {CreateRepoOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCurrentUserRepo(body?: CreateRepoOption, options?: any): AxiosPromise<Repository> {
            return localVarFp.createCurrentUserRepo(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSettings(options?: any): AxiosPromise<Array<UserSettings>> {
            return localVarFp.getUserSettings(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a Token to verify
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVerificationToken(options?: any): AxiosPromise<string> {
            return localVarFp.getVerificationToken(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user settings
         * @param {UserSettingsOptions} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserSettings(body?: UserSettingsOptions, options?: any): AxiosPromise<Array<UserSettings>> {
            return localVarFp.updateUserSettings(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Add email addresses
         * @param {CreateEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAddEmail(body?: CreateEmailOption, options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.userAddEmail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Blocks a user from the doer.
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBlockUser(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userBlockUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if one user is following another user
         * @param {string} username username of following user
         * @param {string} target username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCheckFollowing(username: string, target: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCheckFollowing(username, target, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a hook
         * @param {CreateHookOption} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateHook(body: CreateHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.userCreateHook(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary creates a new OAuth2 application
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userCreateOAuth2Application(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create an access token
         * @param {string} username username of user
         * @param {CreateAccessTokenOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCreateToken(username: string, body?: CreateAccessTokenOption, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.userCreateToken(username, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check whether a user is followed by the authenticated user
         * @param {string} username username of followed user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckFollowing(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentCheckFollowing(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Whether the authenticated is starring the repo
         * @param {string} owner owner of the repo
         * @param {string} repo name of the repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentCheckStarring(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentCheckStarring(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unfollow a user
         * @param {string} username username of user to unfollow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteFollow(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteFollow(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove a GPG key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteGPGKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteGPGKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a public key
         * @param {number} id id of key to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteKey(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unstar the given repo
         * @param {string} owner owner of the repo to unstar
         * @param {string} repo name of the repo to unstar
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentDeleteStar(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentDeleteStar(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a GPG key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetGPGKey(id: number, options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userCurrentGetGPGKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a public key
         * @param {number} id id of key to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentGetKey(id: number, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.userCurrentGetKey(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s followers
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowers(page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userCurrentListFollowers(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the users that the authenticated user is following
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListFollowing(page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userCurrentListFollowing(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s GPG keys
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListGPGKeys(page?: number, limit?: number, options?: any): AxiosPromise<Array<GPGKey>> {
            return localVarFp.userCurrentListGPGKeys(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s public keys
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PublicKey>> {
            return localVarFp.userCurrentListKeys(fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repos that the authenticated user owns
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListRepos(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListRepos(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The repos that the authenticated user has starred
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListStarred(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListStarred(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List repositories watched by the authenticated user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentListSubscriptions(page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userCurrentListSubscriptions(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a GPG key
         * @param {CreateGPGKeyOption} [form] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userCurrentPostGPGKey(form, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a public key
         * @param {CreateKeyOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPostKey(body?: CreateKeyOption, options?: any): AxiosPromise<PublicKey> {
            return localVarFp.userCurrentPostKey(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Follow a user
         * @param {string} username username of user to follow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutFollow(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentPutFollow(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Star the given repo
         * @param {string} owner owner of the repo to star
         * @param {string} repo name of the repo to star
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentPutStar(owner: string, repo: string, options?: any): AxiosPromise<void> {
            return localVarFp.userCurrentPutStar(owner, repo, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the current user\'s tracked times
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
         * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: any): AxiosPromise<Array<TrackedTime>> {
            return localVarFp.userCurrentTrackedTimes(page, limit, since, before, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete an access token
         * @param {string} username username of user
         * @param {string} token token to be deleted, identified by ID and if not available by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteAccessToken(username: string, token: string, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteAccessToken(username, token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete email addresses
         * @param {DeleteEmailOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteEmail(body?: DeleteEmailOption, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteEmail(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a hook
         * @param {number} id id of the hook to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteHook(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary delete an OAuth2 Application
         * @param {number} id token to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userDeleteOAuth2Application(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.userDeleteOAuth2Application(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a hook
         * @param {number} id id of the hook to update
         * @param {EditHookOption} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEditHook(id: number, body?: EditHookOption, options?: any): AxiosPromise<Hook> {
            return localVarFp.userEditHook(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGet(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.userGet(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get the authenticated user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetCurrent(options?: any): AxiosPromise<User> {
            return localVarFp.userGetCurrent(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a user\'s heatmap
         * @param {string} username username of user to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHeatmapData(username: string, options?: any): AxiosPromise<Array<UserHeatmapData>> {
            return localVarFp.userGetHeatmapData(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a hook
         * @param {number} id id of the hook to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetHook(id: number, options?: any): AxiosPromise<Hook> {
            return localVarFp.userGetHook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary get an OAuth2 Application
         * @param {number} id Application ID to be found
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOAuth2Application(id: number, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userGetOAuth2Application(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s oauth2 applications
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetOauth2Application(page?: number, limit?: number, options?: any): AxiosPromise<Array<OAuth2Application>> {
            return localVarFp.userGetOauth2Application(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get list of all existing stopwatches
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetStopWatches(page?: number, limit?: number, options?: any): AxiosPromise<Array<StopWatch>> {
            return localVarFp.userGetStopWatches(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s access tokens
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userGetTokens(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.userGetTokens(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List a user\'s activity feeds
         * @param {string} username username of user
         * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
         * @param {string} [date] the date of the activities to be found
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Activity>> {
            return localVarFp.userListActivityFeeds(username, onlyPerformedBy, date, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s blocked users
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListBlockedUsers(page?: number, limit?: number, options?: any): AxiosPromise<Array<BlockedUser>> {
            return localVarFp.userListBlockedUsers(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s email addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListEmails(options?: any): AxiosPromise<Array<Email>> {
            return localVarFp.userListEmails(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s followers
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowers(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userListFollowers(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the users that the given user is following
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListFollowing(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.userListFollowing(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s GPG keys
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListGPGKeys(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<GPGKey>> {
            return localVarFp.userListGPGKeys(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the authenticated user\'s webhooks
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListHooks(page?: number, limit?: number, options?: any): AxiosPromise<Array<Hook>> {
            return localVarFp.userListHooks(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the given user\'s public keys
         * @param {string} username username of user
         * @param {string} [fingerprint] fingerprint of the key
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<PublicKey>> {
            return localVarFp.userListKeys(username, fingerprint, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repos owned by the given user
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListRepos(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListRepos(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The repos that the given user has starred
         * @param {string} username username of user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListStarred(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListStarred(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List the repositories watched by a user
         * @param {string} username username of the user
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListSubscriptions(username: string, page?: number, limit?: number, options?: any): AxiosPromise<Array<Repository>> {
            return localVarFp.userListSubscriptions(username, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all the teams a user belongs to
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userListTeams(page?: number, limit?: number, options?: any): AxiosPromise<Array<Team>> {
            return localVarFp.userListTeams(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Search for users
         * @param {string} [q] keyword
         * @param {number} [uid] ID of the user to search for
         * @param {number} [page] page number of results to return (1-based)
         * @param {number} [limit] page size of results
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: any): AxiosPromise<UserSearch200Response> {
            return localVarFp.userSearch(q, uid, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Unblocks a user from the doer.
         * @param {string} username username of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUnblockUser(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.userUnblockUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary update an OAuth2 Application, this includes regenerating the client secret
         * @param {number} id application to be updated
         * @param {CreateOAuth2ApplicationOptions} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: any): AxiosPromise<OAuth2Application> {
            return localVarFp.userUpdateOAuth2Application(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify a GPG key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userVerifyGPGKey(options?: any): AxiosPromise<GPGKey> {
            return localVarFp.userVerifyGPGKey(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - interface
 * @export
 * @interface UserApi
 */
export interface UserApiInterface {
    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig): AxiosPromise<Repository>;

    /**
     * 
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getUserSettings(options?: AxiosRequestConfig): AxiosPromise<Array<UserSettings>>;

    /**
     * 
     * @summary Get a Token to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    getVerificationToken(options?: AxiosRequestConfig): AxiosPromise<string>;

    /**
     * 
     * @summary Update user settings
     * @param {UserSettingsOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    updateUserSettings(body?: UserSettingsOptions, options?: AxiosRequestConfig): AxiosPromise<Array<UserSettings>>;

    /**
     * 
     * @summary Add email addresses
     * @param {CreateEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userAddEmail(body?: CreateEmailOption, options?: AxiosRequestConfig): AxiosPromise<Array<Email>>;

    /**
     * 
     * @summary Blocks a user from the doer.
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userBlockUser(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Check if one user is following another user
     * @param {string} username username of following user
     * @param {string} target username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCheckFollowing(username: string, target: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Create a hook
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCreateHook(body: CreateHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary creates a new OAuth2 application
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): AxiosPromise<OAuth2Application>;

    /**
     * 
     * @summary Create an access token
     * @param {string} username username of user
     * @param {CreateAccessTokenOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCreateToken(username: string, body?: CreateAccessTokenOption, options?: AxiosRequestConfig): AxiosPromise<AccessToken>;

    /**
     * 
     * @summary Check whether a user is followed by the authenticated user
     * @param {string} username username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentCheckFollowing(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Whether the authenticated is starring the repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentCheckStarring(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unfollow a user
     * @param {string} username username of user to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteFollow(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Remove a GPG key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteGPGKey(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a public key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteKey(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Unstar the given repo
     * @param {string} owner owner of the repo to unstar
     * @param {string} repo name of the repo to unstar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentDeleteStar(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Get a GPG key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentGetGPGKey(id: number, options?: AxiosRequestConfig): AxiosPromise<GPGKey>;

    /**
     * 
     * @summary Get a public key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentGetKey(id: number, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @summary List the authenticated user\'s followers
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListFollowers(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the users that the authenticated user is following
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListFollowing(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the authenticated user\'s GPG keys
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListGPGKeys(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<GPGKey>>;

    /**
     * 
     * @summary List the authenticated user\'s public keys
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PublicKey>>;

    /**
     * 
     * @summary List the repos that the authenticated user owns
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListRepos(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary The repos that the authenticated user has starred
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListStarred(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List repositories watched by the authenticated user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentListSubscriptions(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary Create a GPG key
     * @param {CreateGPGKeyOption} [form] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: AxiosRequestConfig): AxiosPromise<GPGKey>;

    /**
     * 
     * @summary Create a public key
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPostKey(body?: CreateKeyOption, options?: AxiosRequestConfig): AxiosPromise<PublicKey>;

    /**
     * 
     * @summary Follow a user
     * @param {string} username username of user to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPutFollow(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Star the given repo
     * @param {string} owner owner of the repo to star
     * @param {string} repo name of the repo to star
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentPutStar(owner: string, repo: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary List the current user\'s tracked times
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: AxiosRequestConfig): AxiosPromise<Array<TrackedTime>>;

    /**
     * 
     * @summary delete an access token
     * @param {string} username username of user
     * @param {string} token token to be deleted, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteAccessToken(username: string, token: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete email addresses
     * @param {DeleteEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteEmail(body?: DeleteEmailOption, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Delete a hook
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteHook(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary delete an OAuth2 Application
     * @param {number} id token to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userDeleteOAuth2Application(id: number, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary Update a hook
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary Get a user
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGet(username: string, options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary Get the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetCurrent(options?: AxiosRequestConfig): AxiosPromise<User>;

    /**
     * 
     * @summary Get a user\'s heatmap
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetHeatmapData(username: string, options?: AxiosRequestConfig): AxiosPromise<Array<UserHeatmapData>>;

    /**
     * 
     * @summary Get a hook
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetHook(id: number, options?: AxiosRequestConfig): AxiosPromise<Hook>;

    /**
     * 
     * @summary get an OAuth2 Application
     * @param {number} id Application ID to be found
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetOAuth2Application(id: number, options?: AxiosRequestConfig): AxiosPromise<OAuth2Application>;

    /**
     * 
     * @summary List the authenticated user\'s oauth2 applications
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetOauth2Application(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<OAuth2Application>>;

    /**
     * 
     * @summary Get list of all existing stopwatches
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetStopWatches(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<StopWatch>>;

    /**
     * 
     * @summary List the authenticated user\'s access tokens
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userGetTokens(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<AccessToken>>;

    /**
     * 
     * @summary List a user\'s activity feeds
     * @param {string} username username of user
     * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Activity>>;

    /**
     * 
     * @summary List the authenticated user\'s blocked users
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListBlockedUsers(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<BlockedUser>>;

    /**
     * 
     * @summary List the authenticated user\'s email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListEmails(options?: AxiosRequestConfig): AxiosPromise<Array<Email>>;

    /**
     * 
     * @summary List the given user\'s followers
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListFollowers(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the users that the given user is following
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListFollowing(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<User>>;

    /**
     * 
     * @summary List the given user\'s GPG keys
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListGPGKeys(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<GPGKey>>;

    /**
     * 
     * @summary List the authenticated user\'s webhooks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListHooks(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Hook>>;

    /**
     * 
     * @summary List the given user\'s public keys
     * @param {string} username username of user
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<PublicKey>>;

    /**
     * 
     * @summary List the repos owned by the given user
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListRepos(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary The repos that the given user has starred
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListStarred(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List the repositories watched by a user
     * @param {string} username username of the user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListSubscriptions(username: string, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Repository>>;

    /**
     * 
     * @summary List all the teams a user belongs to
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userListTeams(page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<Array<Team>>;

    /**
     * 
     * @summary Search for users
     * @param {string} [q] keyword
     * @param {number} [uid] ID of the user to search for
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: AxiosRequestConfig): AxiosPromise<UserSearch200Response>;

    /**
     * 
     * @summary Unblocks a user from the doer.
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userUnblockUser(username: string, options?: AxiosRequestConfig): AxiosPromise<void>;

    /**
     * 
     * @summary update an OAuth2 Application, this includes regenerating the client secret
     * @param {number} id application to be updated
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig): AxiosPromise<OAuth2Application>;

    /**
     * 
     * @summary Verify a GPG key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApiInterface
     */
    userVerifyGPGKey(options?: AxiosRequestConfig): AxiosPromise<GPGKey>;

}

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI implements UserApiInterface {
    /**
     * 
     * @summary Create a repository
     * @param {CreateRepoOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createCurrentUserRepo(body?: CreateRepoOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createCurrentUserRepo(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserSettings(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserSettings(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a Token to verify
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getVerificationToken(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getVerificationToken(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user settings
     * @param {UserSettingsOptions} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserSettings(body?: UserSettingsOptions, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserSettings(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Add email addresses
     * @param {CreateEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userAddEmail(body?: CreateEmailOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userAddEmail(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Blocks a user from the doer.
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userBlockUser(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userBlockUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if one user is following another user
     * @param {string} username username of following user
     * @param {string} target username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCheckFollowing(username: string, target: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCheckFollowing(username, target, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a hook
     * @param {CreateHookOption} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateHook(body: CreateHookOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateHook(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary creates a new OAuth2 application
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateOAuth2Application(body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateOAuth2Application(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create an access token
     * @param {string} username username of user
     * @param {CreateAccessTokenOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCreateToken(username: string, body?: CreateAccessTokenOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCreateToken(username, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check whether a user is followed by the authenticated user
     * @param {string} username username of followed user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentCheckFollowing(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentCheckFollowing(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Whether the authenticated is starring the repo
     * @param {string} owner owner of the repo
     * @param {string} repo name of the repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentCheckStarring(owner: string, repo: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentCheckStarring(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unfollow a user
     * @param {string} username username of user to unfollow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteFollow(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteFollow(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove a GPG key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteGPGKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteGPGKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a public key
     * @param {number} id id of key to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unstar the given repo
     * @param {string} owner owner of the repo to unstar
     * @param {string} repo name of the repo to unstar
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentDeleteStar(owner: string, repo: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentDeleteStar(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a GPG key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentGetGPGKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentGetGPGKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a public key
     * @param {number} id id of key to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentGetKey(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentGetKey(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s followers
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListFollowers(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListFollowers(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the users that the authenticated user is following
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListFollowing(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListFollowing(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s GPG keys
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListGPGKeys(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListGPGKeys(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s public keys
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListKeys(fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListKeys(fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repos that the authenticated user owns
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListRepos(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListRepos(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The repos that the authenticated user has starred
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListStarred(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListStarred(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List repositories watched by the authenticated user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentListSubscriptions(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentListSubscriptions(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a GPG key
     * @param {CreateGPGKeyOption} [form] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPostGPGKey(form?: CreateGPGKeyOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPostGPGKey(form, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a public key
     * @param {CreateKeyOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPostKey(body?: CreateKeyOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPostKey(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Follow a user
     * @param {string} username username of user to follow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPutFollow(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPutFollow(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Star the given repo
     * @param {string} owner owner of the repo to star
     * @param {string} repo name of the repo to star
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentPutStar(owner: string, repo: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentPutStar(owner, repo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the current user\'s tracked times
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {string} [since] Only show times updated after the given time. This is a timestamp in RFC 3339 format
     * @param {string} [before] Only show times updated before the given time. This is a timestamp in RFC 3339 format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCurrentTrackedTimes(page?: number, limit?: number, since?: string, before?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userCurrentTrackedTimes(page, limit, since, before, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete an access token
     * @param {string} username username of user
     * @param {string} token token to be deleted, identified by ID and if not available by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteAccessToken(username: string, token: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteAccessToken(username, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete email addresses
     * @param {DeleteEmailOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteEmail(body?: DeleteEmailOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteEmail(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a hook
     * @param {number} id id of the hook to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteHook(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary delete an OAuth2 Application
     * @param {number} id token to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userDeleteOAuth2Application(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userDeleteOAuth2Application(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a hook
     * @param {number} id id of the hook to update
     * @param {EditHookOption} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userEditHook(id: number, body?: EditHookOption, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userEditHook(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGet(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGet(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get the authenticated user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetCurrent(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetCurrent(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a user\'s heatmap
     * @param {string} username username of user to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetHeatmapData(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetHeatmapData(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a hook
     * @param {number} id id of the hook to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetHook(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetHook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary get an OAuth2 Application
     * @param {number} id Application ID to be found
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetOAuth2Application(id: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetOAuth2Application(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s oauth2 applications
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetOauth2Application(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetOauth2Application(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get list of all existing stopwatches
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetStopWatches(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetStopWatches(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s access tokens
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userGetTokens(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userGetTokens(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List a user\'s activity feeds
     * @param {string} username username of user
     * @param {boolean} [onlyPerformedBy] if true, only show actions performed by the requested user
     * @param {string} [date] the date of the activities to be found
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListActivityFeeds(username: string, onlyPerformedBy?: boolean, date?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListActivityFeeds(username, onlyPerformedBy, date, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s blocked users
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListBlockedUsers(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListBlockedUsers(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s email addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListEmails(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListEmails(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s followers
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListFollowers(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListFollowers(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the users that the given user is following
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListFollowing(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListFollowing(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s GPG keys
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListGPGKeys(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListGPGKeys(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the authenticated user\'s webhooks
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListHooks(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListHooks(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the given user\'s public keys
     * @param {string} username username of user
     * @param {string} [fingerprint] fingerprint of the key
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListKeys(username: string, fingerprint?: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListKeys(username, fingerprint, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repos owned by the given user
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListRepos(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListRepos(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The repos that the given user has starred
     * @param {string} username username of user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListStarred(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListStarred(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List the repositories watched by a user
     * @param {string} username username of the user
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListSubscriptions(username: string, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListSubscriptions(username, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all the teams a user belongs to
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userListTeams(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userListTeams(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Search for users
     * @param {string} [q] keyword
     * @param {number} [uid] ID of the user to search for
     * @param {number} [page] page number of results to return (1-based)
     * @param {number} [limit] page size of results
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSearch(q?: string, uid?: number, page?: number, limit?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userSearch(q, uid, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Unblocks a user from the doer.
     * @param {string} username username of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUnblockUser(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUnblockUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary update an OAuth2 Application, this includes regenerating the client secret
     * @param {number} id application to be updated
     * @param {CreateOAuth2ApplicationOptions} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userUpdateOAuth2Application(id: number, body: CreateOAuth2ApplicationOptions, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userUpdateOAuth2Application(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify a GPG key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userVerifyGPGKey(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userVerifyGPGKey(options).then((request) => request(this.axios, this.basePath));
    }
}

